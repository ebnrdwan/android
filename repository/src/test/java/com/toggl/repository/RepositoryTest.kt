package com.toggl.repository

import com.toggl.database.dao.ClientDao
import com.toggl.database.dao.ProjectDao
import com.toggl.database.dao.TagDao
import com.toggl.database.dao.TimeEntryDao
import com.toggl.database.dao.WorkspaceDao
import com.toggl.database.models.DatabaseTimeEntry
import com.toggl.database.models.DatabaseWorkspace
import com.toggl.environment.services.time.TimeService
import com.toggl.models.domain.TimeEntry
import com.toggl.models.domain.WorkspaceFeature
import com.toggl.repository.extensions.toDatabaseTimeEntry
import com.toggl.repository.extensions.toDatabaseModel
import com.toggl.repository.extensions.toModel
import com.toggl.repository.interfaces.StartTimeEntryResult
import io.kotlintest.TestCase
import io.kotlintest.matchers.collections.shouldBeEmpty
import io.kotlintest.shouldBe
import io.kotlintest.specs.StringSpec
import io.mockk.called
import io.mockk.clearMocks
import io.mockk.coEvery
import io.mockk.coVerify
import io.mockk.every
import io.mockk.mockk
import io.mockk.spyk
import io.mockk.verify
import org.threeten.bp.Duration
import org.threeten.bp.OffsetDateTime

class RepositoryTest : StringSpec() {
    private val tagDao = mockk<TagDao>()
    private val projectDao = mockk<ProjectDao>()
    private val timeEntryDao = mockk<TimeEntryDao>()
    private val workspaceDao = mockk<WorkspaceDao>()
    private val clientDao = mockk<ClientDao>()
    private val timeService = mockk<TimeService>()
    private var repository = Repository(projectDao, timeEntryDao, workspaceDao, clientDao, tagDao, timeService)

    override fun beforeTest(testCase: TestCase) {
        super.beforeTest(testCase)
        clearMocks(timeEntryDao, workspaceDao, clientDao, timeService)
    }

    init {
        "loadTimeEntries calls getAllTimeEntriesWithTags on the DAO" {
            every { timeEntryDao.getAllTimeEntriesWithTags() } returns listOf()

            val loaded = repository.loadTimeEntries()

            verify(exactly = 1) { timeEntryDao.getAllTimeEntriesWithTags() }
            verify {
                workspaceDao wasNot called
                timeService wasNot called
                clientDao wasNot called
            }
            loaded.shouldBeEmpty()
        }

        "loadClients calls getAll on the DAO" {
            every { clientDao.getAll() } returns listOf()

            val loaded = repository.loadClients()

            verify(exactly = 1) { clientDao.getAll() }
            verify {
                workspaceDao wasNot called
                timeService wasNot called
                timeEntryDao wasNot called
                projectDao wasNot called
            }
            loaded.shouldBeEmpty()
        }

        "loadTags calls getAll on the DAO" {
            every { tagDao.getAll() } returns listOf()

            val loaded = repository.loadTags()

            verify(exactly = 1) { tagDao.getAll() }
            verify {
                workspaceDao wasNot called
                timeService wasNot called
                timeEntryDao wasNot called
                projectDao wasNot called
            }
            loaded.shouldBeEmpty()
        }

        "loadWorkspaces calls getAll on the DAO and returns elements if there are any" {
            val someWorkspace = DatabaseWorkspace(
                123,
                "Workspace name",
                features = listOf()
            )
            every { workspaceDao.getAll() } returns listOf(someWorkspace)

            val loaded = repository.loadWorkspaces()

            verify(exactly = 1) { workspaceDao.getAll() }
            verify {
                timeEntryDao wasNot called
                timeService wasNot called
                clientDao wasNot called
            }
            loaded shouldBe listOf(someWorkspace.toModel())
        }

        "loadWorkspaces calls getAll on the DAO and returns an auto-generated workspace if there aren't any workspaces returned by DAO" {
            every { workspaceDao.getAll() } returns listOf()
            every { workspaceDao.insert(any()) } returns 1337
            val autoGeneratedWorkspace = DatabaseWorkspace(
                0,
                "Auto created workspace",
                listOf(
                    WorkspaceFeature.Pro
                )
            )

            val loaded = repository.loadWorkspaces()

            verify(exactly = 1) { workspaceDao.insert(autoGeneratedWorkspace) }
            verify {
                timeEntryDao wasNot called
                timeService wasNot called
                clientDao wasNot called
            }
            loaded shouldBe listOf(autoGeneratedWorkspace.copy(id = 1337).toModel())
        }

        "stopRunningTimeEntry updates all running time entries and returns the first one" {
            val timeEntryOneStartTime = OffsetDateTime.parse("2019-07-17T17:15:17+01:00")
            val timeEntryRunningOne =
                DatabaseTimeEntry(
                    1,
                    "one running",
                    timeEntryOneStartTime,
                    null,
                    false,
                    0,
                    0,
                    0,
                    false
                )
            val timeEntryTwoStartTime = OffsetDateTime.parse("2019-07-17T12:17:17+01:00")
            val timeEntryRunningTwo = timeEntryRunningOne.copy(
                id = 3,
                startTime = timeEntryTwoStartTime
            )
            val nowTime = OffsetDateTime.parse("2019-07-17T17:17:17+01:00")
            every { timeService.now() } returns nowTime
            every { timeEntryDao.getAllRunningTimeEntries() } returns listOf(
                timeEntryRunningOne,
                timeEntryRunningTwo
            )
            every { timeEntryDao.updateAllTimeEntries(any()) } returns mockk()

            val result = repository.stopRunningTimeEntry()

            verify(exactly = 1) {
                timeEntryDao.updateAllTimeEntries(
                    listOf(
                        timeEntryRunningOne.copy(
                            duration = Duration.between(
                                timeEntryOneStartTime,
                                nowTime
                            )
                        ),
                        timeEntryRunningTwo.copy(
                            duration = Duration.between(
                                timeEntryTwoStartTime,
                                nowTime
                            )
                        )
                    )
                )
            }
            verify {
                workspaceDao wasNot called
                clientDao wasNot called
            }
            result shouldBe timeEntryRunningOne.copy(
                duration = Duration.between(
                    timeEntryOneStartTime,
                    nowTime
                )
            ).toModel()
        }

        "stopRunningTimeEntry doesn't update any time entries if none are running and doesn't return any time entries" {
            every { timeEntryDao.getAllRunningTimeEntries() } returns listOf()
            every { timeService.now() } returns mockk()
            every { timeEntryDao.updateAllTimeEntries(any()) } returns mockk()

            val result = repository.stopRunningTimeEntry()

            verify(exactly = 1) { timeEntryDao.updateAllTimeEntries(listOf()) }
            verify {
                workspaceDao wasNot called
                clientDao wasNot called
            }
            result shouldBe null
        }

        "startTimeEntry stops currently running time entry and inserts a new one to DAO" {
            val nowTime = OffsetDateTime.parse("2019-07-17T17:17:17+01:00")
            val startedTimeEntry = TimeEntry(
                1337,
                "desc",
                nowTime,
                null,
                false,
                1,
                null,
                null,
                false,
                emptyList()
            )
            val stoppedTimeEntry = TimeEntry(
                336,
                "was running",
                nowTime.minusHours(1),
                Duration.ofHours(1), false, 1, null, null, false, emptyList()
            )
            coEvery { repository.stopRunningTimeEntry() } returns stoppedTimeEntry
            every { timeEntryDao.insertTimeEntry(any()) } returns 1337
            every { timeEntryDao.getOneTimeEntry(any()) } returns startedTimeEntry.toDatabaseTimeEntry()
            every { timeService.now() } returns nowTime
            every { timeEntryDao.getAllRunningTimeEntries() } returns listOf(stoppedTimeEntry.copy(duration = null).toDatabaseTimeEntry())
            every { timeEntryDao.updateAllTimeEntries(any()) } returns mockk()
            val repositorySpy = spyk(repository)

            val result = repositorySpy.startTimeEntry(1, "desc")

            coVerify(exactly = 1) {
                repositorySpy.stopRunningTimeEntry()
            }
            verify(exactly = 1) {
                timeEntryDao.insertTimeEntry(startedTimeEntry.copy(id = 0).toDatabaseTimeEntry())
                timeEntryDao.getOneTimeEntry(1337)
            }
            verify {
                workspaceDao wasNot called
                clientDao wasNot called
            }
            result shouldBe StartTimeEntryResult(startedTimeEntry, stoppedTimeEntry)
        }

        "editTimeEntry updates the time entry and returns it" {
            val nowTime = OffsetDateTime.parse("2019-07-17T17:17:17+01:00")
            val timeEntry = spyk<TimeEntry>(
                TimeEntry(1, "desc", nowTime, null, false, 1, null, null, false, emptyList())
            )
            every { timeEntryDao.updateTimeEntryWithTags(any()) } returns mockk()

            val result = repository.editTimeEntry(timeEntry)

            verify {
                workspaceDao wasNot called
                timeService wasNot called
                clientDao wasNot called
            }
            result shouldBe timeEntry
        }

        "deleteTimeEntry sets isDeleted, updates the DAO and returns the updated entries" {
            val timeEntry = TimeEntry(
                1337,
                "desc",
                OffsetDateTime.MAX,
                null,
                false,
                1,
                null,
                null,
                false,
                emptyList()
            )
            every { timeEntryDao.updateTimeEntryWithTags(any()) } returns mockk()

            val result =
                repository.deleteTimeEntry(timeEntry)

            verify(exactly = 1) {
                timeEntryDao.updateTimeEntryWithTags(timeEntry.copy(isDeleted = true).toDatabaseModel())
            }
            verify {
                workspaceDao wasNot called
                timeService wasNot called
                clientDao wasNot called
            }
            result shouldBe timeEntry.copy(isDeleted = true)
        }
    }
}
